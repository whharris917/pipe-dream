<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow State // Industrial Studio</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #191c20;
            font-family: 'Segoe UI', Arial, sans-serif;
            user-select: none;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="appCanvas"></canvas>

    <script>
        /**
         * FLOW STATE // INDUSTRIAL STUDIO (Web Port)
         * * A faithful recreation of the Pygame "folly" engine using HTML5 Canvas.
         */

        // --- CONSTANTS & COLORS ---
        const C_BG = "#191c20";
        const C_SIDEBAR = "#111113"; // Slightly darker for sidebar
        const C_GRID = "#1e1e23";
        const C_ACCENT = "#ffaa00";
        const C_SUCCESS = "#00cc66";
        const C_DANGER = "#ff4444";
        const C_WARNING = "#ffcc00";
        const C_TEXT = "#e0e0e0";
        const C_TEXT_DIM = "#888888";
        const C_PANEL = "rgba(25, 28, 32, 0.9)";

        // --- AUDIO ENGINE ---
        // procedural sound generation to replace local assets
        const AudioEngine = {
            ctx: new (window.AudioContext || window.webkitAudioContext)(),
            
            playTone: function(freq, type, duration, vol=0.1) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
                
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },

            playSound: function(name) {
                // Procedural generation based on name
                if (name.includes("click")) this.playTone(800 + Math.random()*200, "square", 0.05, 0.05);
                else if (name.includes("beep")) this.playTone(400 + Math.random()*100, "sine", 0.15, 0.1);
                else if (name.includes("bloop")) {
                    this.playTone(300, "sine", 0.2, 0.1);
                    setTimeout(() => this.playTone(600, "sine", 0.1, 0.1), 50);
                }
                else if (name.includes("siren")) {
                     this.playTone(700, "sawtooth", 0.5, 0.05);
                }
            },
            
            // Placeholder for music
            playMusic: function(trackName) { console.log("Playing track:", trackName); },
            stopMusic: function() { console.log("Music stopped"); }
        };

        // --- INPUT HANDLING ---
        const Input = {
            x: 0, y: 0,
            clicked: false,
            down: false,
            
            update: function() {
                this.clicked = false; // Reset click frame
            }
        };

        window.addEventListener('mousemove', e => { Input.x = e.clientX; Input.y = e.clientY; });
        window.addEventListener('mousedown', () => { Input.down = true; Input.clicked = true; });
        window.addEventListener('mouseup', () => { Input.down = false; });

        // --- UI BASE CLASSES ---
        
        class Widget {
            constructor(x, y, w, h) {
                this.x = x; this.y = y; this.w = w; this.h = h;
                this.hovered = false;
                this.active = false;
                this.disabled = false;
            }

            contains(mx, my) {
                return mx >= this.x && mx <= this.x + this.w && my >= this.y && my <= this.y + this.h;
            }

            update(dt) {
                if (this.disabled) return;
                this.hovered = this.contains(Input.x, Input.y);
            }
            
            draw(ctx) {}
        }

        class JuicyButton extends Widget {
            constructor(x, y, w, h, opts={}) {
                super(x, y, w, h);
                this.text = opts.text || "";
                this.icon = opts.icon_name || null;
                this.style = opts.style || "default"; // default, primary, danger, success
                this.sound_name = opts.sound_name || "click_1";
                this.click_trigger = false;
                
                // Extra props for music UI
                this.track_to_play = null;
                this.is_stop_btn = false;
            }

            update(dt) {
                super.update(dt);
                this.click_trigger = false;
                if (this.hovered && Input.clicked && !this.disabled) {
                    this.click_trigger = true;
                    AudioEngine.playSound(this.sound_name);
                }
            }

            get clicked() { return this.click_trigger; }

            draw(ctx) {
                let col = "#333";
                let border = "#555";
                let txtCol = C_TEXT;

                // Style Logic
                if (this.style === "primary" || this.active) { col = C_ACCENT; txtCol = "#000"; border = C_ACCENT; }
                else if (this.style === "danger") { col = C_DANGER; txtCol = "#fff"; border = C_DANGER; }
                else if (this.style === "success") { col = C_SUCCESS; txtCol = "#000"; border = C_SUCCESS; }
                
                if (this.disabled) {
                    // Header style
                    ctx.fillStyle = "transparent";
                    ctx.font = "bold 14px Segoe UI";
                    ctx.fillStyle = C_ACCENT;
                    ctx.fillText(this.text, this.x, this.y + 20);
                    // Draw separator line
                    ctx.strokeStyle = "#444";
                    ctx.beginPath();
                    ctx.moveTo(this.x + ctx.measureText(this.text).width + 10, this.y + 15);
                    ctx.lineTo(this.x + this.w, this.y + 15);
                    ctx.stroke();
                    return;
                }

                if (this.hovered) {
                    ctx.globalAlpha = 0.8;
                    document.body.style.cursor = 'pointer';
                }
                
                // Draw Body
                ctx.fillStyle = col;
                ctx.strokeStyle = border;
                ctx.lineWidth = 1;

                if (this.style === "default" && !this.active) {
                    ctx.fillStyle = "rgba(255,255,255,0.05)";
                    if(this.hovered) ctx.fillStyle = "rgba(255,255,255,0.1)";
                    ctx.strokeRect(this.x, this.y, this.w, this.h);
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                } else {
                    // Solid fill for colored buttons
                    ctx.fillRect(this.x, this.y, this.w, this.h);
                }
                
                ctx.globalAlpha = 1.0;

                // Draw Text/Icon
                ctx.fillStyle = txtCol;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                if (this.icon) {
                    // Simple Icon Placeholders
                    let cx = this.x + this.w/2;
                    let cy = this.y + this.h/2;
                    ctx.beginPath();
                    if (this.icon === "play") {
                        ctx.moveTo(cx-5, cy-5); ctx.lineTo(cx-5, cy+5); ctx.lineTo(cx+5, cy);
                    } else if (this.icon === "stop") {
                        ctx.rect(cx-5, cy-5, 10, 10);
                    } else if (this.icon === "settings") {
                        ctx.arc(cx, cy, 6, 0, Math.PI*2);
                        ctx.stroke();
                    } else if (this.icon === "gear") {
                        ctx.arc(cx, cy, 5, 0, Math.PI*2); // Simple gear rep
                        for(let i=0; i<8; i++) {
                            let a = (i/8)*Math.PI*2;
                            ctx.moveTo(cx + Math.cos(a)*4, cy + Math.sin(a)*4);
                            ctx.lineTo(cx + Math.cos(a)*8, cy + Math.sin(a)*8);
                        }
                        ctx.stroke();
                    }
                     else {
                         // Default icon fallback
                         ctx.fillText("★", cx, cy);
                     }
                    ctx.fill();
                } else {
                    ctx.font = "13px Segoe UI";
                    ctx.fillText(this.text, this.x + this.w/2, this.y + this.h/2);
                }
                
                // Reset alignment
                ctx.textAlign = "left";
                ctx.textBaseline = "alphabetic";
            }
        }

        class Checkbox extends Widget {
            constructor(x, y, size, label, checked=false) {
                super(x, y, size, size); // hit box slightly larger for label
                this.label = label;
                this.checked = checked;
                this.w = size + 150; // Extend width for label
            }
            update(dt) {
                super.update(dt);
                if (this.hovered && Input.clicked) {
                    this.checked = !this.checked;
                    AudioEngine.playSound("click");
                }
            }
            draw(ctx) {
                // Box
                let size = 20;
                ctx.strokeStyle = C_TEXT_DIM;
                ctx.strokeRect(this.x, this.y, size, size);
                
                if (this.checked) {
                    ctx.fillStyle = C_ACCENT;
                    ctx.fillRect(this.x + 4, this.y + 4, size - 8, size - 8);
                }
                
                // Label
                ctx.fillStyle = this.hovered ? C_TEXT : C_TEXT_DIM;
                ctx.font = "14px Segoe UI";
                ctx.fillText(this.label, this.x + 30, this.y + 15);
            }
        }

        class Slider extends Widget {
            constructor(x, y, w, val=0.5) {
                super(x, y, w, 20);
                this.val = val;
                this.dragging = false;
            }
            update(dt) {
                super.update(dt);
                if (this.hovered && Input.clicked) this.dragging = true;
                if (!Input.down) this.dragging = false;
                
                if (this.dragging) {
                    let mouseRel = Input.x - this.x;
                    this.val = Math.max(0, Math.min(1, mouseRel / this.w));
                }
            }
            draw(ctx) {
                // Track
                ctx.fillStyle = "#333";
                ctx.fillRect(this.x, this.y + 8, this.w, 4);
                // Fill
                ctx.fillStyle = C_ACCENT;
                ctx.fillRect(this.x, this.y + 8, this.w * this.val, 4);
                // Knob
                ctx.fillStyle = "#fff";
                ctx.beginPath();
                ctx.arc(this.x + this.w * this.val, this.y + 10, 8, 0, Math.PI*2);
                ctx.fill();
            }
        }

        class Knob extends Widget {
            constructor(x, y, r, val=0.0) {
                super(x - r, y - r, r*2, r*2);
                this.r = r;
                this.val = val;
                this.dragging = false;
            }
            update(dt) {
                super.update(dt); // knob logic simplified for web
                if(this.hovered && Input.clicked) this.dragging = true;
                if(!Input.down) this.dragging = false;
                if(this.dragging) {
                    this.val = Math.max(0, Math.min(1, this.val - (Input.y - (this.y+this.r))*0.01 )); // simple vertical drag
                }
            }
            draw(ctx) {
                let cx = this.x + this.r;
                let cy = this.y + this.r;
                ctx.strokeStyle = C_TEXT_DIM;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cx, cy, this.r, 0.75 * Math.PI, 2.25 * Math.PI); // Background arc
                ctx.stroke();

                ctx.strokeStyle = C_ACCENT;
                let endAngle = 0.75 * Math.PI + (1.5 * Math.PI * this.val);
                ctx.beginPath();
                ctx.arc(cx, cy, this.r, 0.75 * Math.PI, endAngle);
                ctx.stroke();
                ctx.lineWidth = 1;
            }
        }

        class ProgressBar extends Widget {
            constructor(x, y, w, h, val=0) {
                super(x, y, w, h);
                this.val = val;
                this.time = 0;
            }
            update(dt) {
                this.time += dt;
                this.val = 0.4 + Math.sin(this.time * 2) * 0.3; // Animate specifically for demo
            }
            draw(ctx) {
                ctx.fillStyle = "#222";
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = this.val > 0.8 ? C_DANGER : C_ACCENT;
                ctx.fillRect(this.x, this.y, this.w * this.val, this.h);
                
                // Stripes
                ctx.fillStyle = "rgba(0,0,0,0.2)";
                for(let i=0; i<this.w; i+=10) ctx.fillRect(this.x+i, this.y, 2, this.h);
            }
        }

        class TextInput extends Widget {
            constructor(x, y, w, h, placeholder) {
                super(x, y, w, h);
                this.text = placeholder;
            }
            draw(ctx) {
                ctx.fillStyle = "#222";
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = "#444";
                ctx.strokeRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = "#666";
                ctx.font = "italic 14px Segoe UI";
                ctx.fillText(this.text, this.x + 10, this.y + 25);
            }
        }
        
        class Dropdown extends Widget {
             constructor(x, y, w, h, items) {
                super(x, y, w, h);
                this.items = items;
                this.selected = items[0];
            }
            draw(ctx) {
                ctx.fillStyle = "#222";
                ctx.fillRect(this.x, this.y, this.w, this.h);
                ctx.strokeStyle = "#444";
                ctx.strokeRect(this.x, this.y, this.w, this.h);
                ctx.fillStyle = C_TEXT;
                ctx.font = "14px Segoe UI";
                ctx.fillText(this.selected + " ▼", this.x + 10, this.y + 25);
            }
        }

        // --- FACTORY WIDGETS (VISUALS) ---
        // A generic class that uses a render function to vary appearance
        class FactoryWidget extends Widget {
            constructor(x, y, size, type, opts={}) {
                super(x, y, size, size);
                this.type = type;
                this.time = Math.random() * 100;
                this.speed = opts.speed || 1;
                this.color = opts.color || C_ACCENT;
                this.opts = opts;
            }
            update(dt) {
                super.update(dt);
                this.time += dt * this.speed;
            }
            draw(ctx) {
                let cx = this.x + this.w/2;
                let cy = this.y + this.h/2;
                let r = this.w/2 - 2;

                ctx.strokeStyle = "#555";
                ctx.strokeRect(this.x, this.y, this.w, this.h); // Border
                
                ctx.save();
                ctx.translate(cx, cy);

                if (this.type === 'gear') {
                    ctx.rotate(this.time);
                    ctx.fillStyle = C_TEXT_DIM;
                    // Draw Gear
                    ctx.beginPath();
                    let teeth = 8;
                    for (let i = 0; i < teeth * 2; i++) {
                        let a = (Math.PI * 2 * i) / (teeth * 2);
                        let rad = (i % 2 === 0) ? r : r * 0.6;
                        ctx.lineTo(Math.cos(a) * rad, Math.sin(a) * rad);
                    }
                    ctx.closePath();
                    ctx.fill();
                    // Center hole
                    ctx.fillStyle = C_BG;
                    ctx.beginPath(); ctx.arc(0,0, r*0.3, 0, Math.PI*2); ctx.fill();
                } 
                else if (this.type === 'fan') {
                    ctx.rotate(this.time * 5);
                    ctx.fillStyle = C_TEXT;
                    for(let i=0; i<3; i++) {
                        ctx.fillRect(-2, -r, 4, r*2);
                        ctx.rotate(Math.PI*2/3);
                    }
                }
                else if (this.type === 'light') {
                    let on = Math.sin(this.time) > 0;
                    ctx.fillStyle = on ? this.color : "#333";
                    ctx.beginPath(); ctx.arc(0,0, r*0.7, 0, Math.PI*2); ctx.fill();
                }
                else if (this.type === 'tank') {
                    ctx.fillStyle = "#333";
                    ctx.fillRect(-r, -r, r*2, r*2);
                    // Liquid level
                    let lvl = (Math.sin(this.time)+1)/2;
                    ctx.fillStyle = this.opts.fluid_col || C_ACCENT;
                    ctx.fillRect(-r, r - (r*2*lvl), r*2, r*2*lvl);
                }
                else if (this.type === 'gauge') {
                    ctx.strokeStyle = C_TEXT;
                    ctx.beginPath(); ctx.arc(0,0, r*0.8, Math.PI, 0); ctx.stroke();
                    let angle = Math.PI + (Math.sin(this.time)+1)/2 * Math.PI;
                    ctx.strokeStyle = C_DANGER;
                    ctx.beginPath(); ctx.moveTo(0,0); 
                    ctx.lineTo(Math.cos(angle)*r*0.8, Math.sin(angle)*r*0.8);
                    ctx.stroke();
                }
                else if (this.type === 'hazard') {
                     // Hazard Stripes
                     ctx.fillStyle = C_WARNING;
                     ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
                     ctx.fillStyle = "#000";
                     for(let i=-this.w; i<this.w; i+=20) {
                         ctx.beginPath();
                         ctx.moveTo(i, -this.h/2); ctx.lineTo(i+10, -this.h/2);
                         ctx.lineTo(i-10, this.h/2); ctx.lineTo(i-20, this.h/2);
                         ctx.fill();
                     }
                }
                else {
                    // Generic box for others
                    ctx.fillStyle = "#333";
                    ctx.fillRect(-5, -5, 10, 10);
                }
                ctx.restore();
            }
        }

        // --- MAIN APP ---

        const canvas = document.getElementById('appCanvas');
        const ctx = canvas.getContext('2d');
        
        let WIDTH = window.innerWidth;
        let HEIGHT = window.innerHeight;

        function resize() {
            WIDTH = window.innerWidth;
            HEIGHT = window.innerHeight;
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            buildUI(); // Rebuild layout on resize
        }
        window.addEventListener('resize', resize);

        // -- State --
        let currentTab = "SFX";
        let targetTab = "SFX";
        let tabOffset = 0;
        let lastTime = 0;

        // -- Lists --
        let sidebarButtons = [];
        let sfxButtons = [];
        let musicButtons = [];
        let kitWidgets = [];
        let facWidgets = [];

        // -- Generators for Factory --
        function buildFactory() {
            facWidgets = [];
            const fx = 230, fy = 100;
            
            // Header
            let header = new JuicyButton(fx, fy, 250, 30, {text: "// FACTORY DASHBOARD"});
            header.disabled = true;
            facWidgets.push(header);

            const gridCols = 15;
            const size = 30;
            const gap = 8;
            
            const types = [
                () => new FactoryWidget(0,0,size, 'gear', {speed: (Math.random()-0.5)*5}),
                () => new FactoryWidget(0,0,size, 'fan', {speed: 1}),
                () => new FactoryWidget(0,0,size, 'tank', {fluid_col: Math.random() > 0.5 ? C_ACCENT : C_SUCCESS}),
                () => new FactoryWidget(0,0,size, 'light', {color: Math.random() > 0.5 ? C_WARNING : C_DANGER}),
                () => new FactoryWidget(0,0,size, 'gauge', {speed: 2}),
            ];

            for (let i = 0; i < 140; i++) {
                 let col = i % gridCols;
                 let row = Math.floor(i / gridCols);
                 let wx = fx + col * (size + gap);
                 let wy = fy + 50 + row * (size + gap);
                 
                 // Random widget type
                 let w = types[Math.floor(Math.random() * types.length)]();
                 w.x = wx; w.y = wy;
                 facWidgets.push(w);
            }
            
            // Hazard strip at bottom
            let hazard = new FactoryWidget(fx, fy + 50 + (10 * (size+gap)), WIDTH - 300, 40, 'hazard');
            // Hack to override size in constructor
            hazard.w = WIDTH - 300; hazard.h = 40; 
            facWidgets.push(hazard);
        }

        function buildUI() {
            sidebarButtons = [];
            let sbY = 80;
            sidebarButtons.push(new JuicyButton(10, sbY, 180, 45, {text: "Soundboard", icon_name: "settings"})); sbY += 55;
            sidebarButtons.push(new JuicyButton(10, sbY, 180, 45, {text: "Jukebox", icon_name: "play"})); sbY += 55;
            sidebarButtons.push(new JuicyButton(10, sbY, 180, 45, {text: "UI Kit", icon_name: "gear"})); sbY += 55;
            sidebarButtons.push(new JuicyButton(10, sbY, 180, 45, {text: "Factory", icon_name: "gear"}));

            // Identify them for logic
            sidebarButtons[0].tabName = "SFX";
            sidebarButtons[1].tabName = "MUSIC";
            sidebarButtons[2].tabName = "KIT";
            sidebarButtons[3].tabName = "FAC";

            // -- SFX Tab --
            sfxButtons = [];
            let cx = 230, cy = 90;
            const cats = { "Beeps": ["beep_1", "beep_2", "beep_3"], "Bloops": ["bloop_1", "bloop_2"], "Clicks": ["click_1", "click_2", "click_3", "click_4"] };
            
            for (const [cat, items] of Object.entries(cats)) {
                let h = new JuicyButton(cx, cy, WIDTH - 250, 30, {text: `// ${cat.toUpperCase()}`});
                h.disabled = true; sfxButtons.push(h); cy += 40;
                
                items.forEach((item, i) => {
                    let bx = cx + (i * 110);
                    sfxButtons.push(new JuicyButton(bx, cy, 100, 45, {text: item, sound_name: item}));
                });
                cy += 60;
            }

            // -- Music Tab --
            musicButtons = [];
            cy = 90;
            let mh = new JuicyButton(cx, cy, WIDTH-250, 30, {text: "// AVAILABLE TRACKS"});
            mh.disabled = true; musicButtons.push(mh); cy += 40;
            ["Industrial_Hum.wav", "Cyber_Groove.wav", "Factory_Alarm.wav"].forEach(track => {
                let lbl = new JuicyButton(cx, cy, 300, 45, {text: track});
                lbl.disabled = true;
                let btnP = new JuicyButton(cx + 310, cy, 45, 45, {icon_name: "play"});
                let btnS = new JuicyButton(cx + 360, cy, 45, 45, {icon_name: "stop"});
                musicButtons.push(lbl, btnP, btnS);
                cy += 55;
            });

            // -- Kit Tab --
            kitWidgets = [];
            cy = 90;
            kitWidgets.push(new JuicyButton(cx, cy, 200, 30, {text: "// BUTTONS"})); kitWidgets[0].disabled = true; cy += 40;
            kitWidgets.push(new JuicyButton(cx, cy, 120, 40, {text: "Primary", style:"primary"}));
            kitWidgets.push(new JuicyButton(cx+130, cy, 120, 40, {text: "Danger", style:"danger"}));
            kitWidgets.push(new JuicyButton(cx+260, cy, 120, 40, {text: "Success", style:"success"}));
            cy += 60;
            
            kitWidgets.push(new JuicyButton(cx, cy, 200, 30, {text: "// INPUTS"})); 
            kitWidgets[kitWidgets.length-1].disabled=true; cy+=40;
            kitWidgets.push(new Checkbox(cx, cy, 30, "Enable Physics", true));
            kitWidgets.push(new Checkbox(cx+200, cy, 30, "Show Grid", false));
            cy += 50;
            kitWidgets.push(new Slider(cx, cy, 300, 0.4));
            kitWidgets.push(new Knob(cx+350, cy, 25, 0.7));
            cy += 60;
            
            kitWidgets.push(new JuicyButton(cx, cy, 200, 30, {text: "// STATUS"})); 
            kitWidgets[kitWidgets.length-1].disabled=true; cy+=40;
            kitWidgets.push(new ProgressBar(cx, cy, 400, 20));

            // -- Factory Tab --
            buildFactory();

            // Set Initial Active
            sidebarButtons[0].active = true;
        }

        function drawGrid(ctx) {
            ctx.strokeStyle = C_GRID;
            ctx.lineWidth = 1;
            const sz = 60;
            ctx.beginPath();
            for (let x = 0; x < WIDTH; x+=sz) { ctx.moveTo(x,0); ctx.lineTo(x,HEIGHT); }
            for (let y = 0; y < HEIGHT; y+=sz) { ctx.moveTo(0,y); ctx.lineTo(WIDTH,y); }
            ctx.stroke();
        }

        function drawSidebar(ctx) {
            ctx.fillStyle = C_PANEL;
            ctx.fillRect(0, 0, 210, HEIGHT);
            ctx.strokeStyle = "#444";
            ctx.beginPath(); ctx.moveTo(210, 0); ctx.lineTo(210, HEIGHT); ctx.stroke();
            
            // Title
            ctx.fillStyle = C_ACCENT;
            ctx.font = "bold 24px Segoe UI";
            ctx.fillText("FLOW STATE", 20, 40);
            ctx.fillStyle = "#666";
            ctx.font = "14px Segoe UI";
            ctx.fillText("AUDIO STUDIO", 20, 65);
            
            sidebarButtons.forEach(b => b.draw(ctx));
        }

        function loop(timestamp) {
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;

            // 1. Update State
            // Input.update(); <--- Removed from here
            
            // Sidebar Logic
            sidebarButtons.forEach(b => {
                b.update(dt);
                if (b.clicked) {
                    targetTab = b.tabName;
                    sidebarButtons.forEach(sb => sb.active = false);
                    b.active = true;
                    tabOffset = 50; // Slide animation start
                }
            });

            // Tab Slide Animation
            if (tabOffset > 0) tabOffset -= tabOffset * 10 * dt;
            if (tabOffset < 0.1) tabOffset = 0;

            // Update Active Tab Widgets
            let activeWidgets = [];
            if (currentTab !== targetTab) currentTab = targetTab;
            
            if (currentTab === "SFX") activeWidgets = sfxButtons;
            else if (currentTab === "MUSIC") activeWidgets = musicButtons;
            else if (currentTab === "KIT") activeWidgets = kitWidgets;
            else if (currentTab === "FAC") activeWidgets = facWidgets;

            activeWidgets.forEach(w => {
                // Check hover, clicks
                w.update(dt);
            });

            // 2. Draw
            ctx.fillStyle = C_BG;
            ctx.fillRect(0, 0, WIDTH, HEIGHT);
            drawGrid(ctx);

            // Draw Content
            ctx.save();
            ctx.translate(tabOffset, 0); // Apply slide effect
            activeWidgets.forEach(w => w.draw(ctx));
            ctx.restore();

            // Draw Sidebar (on top)
            drawSidebar(ctx);
            
            // Cursor reset (handled in widgets, but safety here)
            if (!sidebarButtons.some(b=>b.hovered) && !activeWidgets.some(w=>w.hovered)) {
                document.body.style.cursor = 'default';
            }

            // Input Reset - Moved to end of loop
            Input.update(); 

            requestAnimationFrame(loop);
        }

        // Init
        resize();
        buildUI();
        requestAnimationFrame(loop);

    </script>
</body>
</html>