---
title: Refactor QMS CLI with Test Coverage
revision_summary: Initial draft
---

# CR-025: Refactor QMS CLI with Test Coverage

## 1. Purpose

Refactor the monolithic `qms-cli/qms.py` (2743 lines, 47 functions) into focused modules while establishing unit test coverage as a safety net for current and future changes.

---

## 2. Scope

### 2.1 Context

Independent improvement identified during development. The QMS CLI has grown organically into a single large file that is difficult to navigate and maintain. No parent document drives this change.

- **Parent Document:** None

### 2.2 Changes Summary

- Create a unit test suite for existing QMS CLI functionality
- Extract logical groupings of functions into focused modules
- Reduce `qms.py` to a slim entry point with argparse and dispatch
- Preserve all existing behavior (refactor, not rewrite)

### 2.3 Files Affected

- `qms-cli/qms.py` - Refactor from 2743 lines to ~200 line entry point
- `qms-cli/qms_config.py` - New module for constants, enums, status, transitions
- `qms-cli/qms_auth.py` - New module for user/permission functions
- `qms-cli/qms_paths.py` - New module for path resolution functions
- `qms-cli/qms_io.py` - New module for frontmatter parsing and document I/O
- `qms-cli/qms_templates.py` - New module for template loading and generation
- `qms-cli/qms_commands.py` - New module for command handlers
- `tests/` - New test directory with unit tests

---

## 3. Current State

`qms-cli/qms.py` is a 2743-line monolith containing 21 command handlers and 26 utility functions. No unit tests exist. Supporting modules (`qms_meta.py`, `qms_audit.py`, `qms_schema.py`) already demonstrate the modular pattern.

---

## 4. Proposed State

`qms.py` is a slim entry point (~200 lines) containing only argparse setup and command dispatch. Functionality is distributed across 6 focused modules. A unit test suite provides a safety net for verifying behavior during and after refactoring.

---

## 5. Change Description

### 5.1 Test Infrastructure

Create `tests/` directory with pytest configuration. Write unit tests for key functions *before* extracting them, establishing a baseline that must pass throughout the refactoring.

### 5.2 Module Extraction Strategy

Extract modules incrementally, running tests after each extraction to verify behavior is preserved. The proposed module structure is:

| Module | Approximate Lines | Purpose |
|--------|-------------------|---------|
| `qms_config.py` | ~150 | Constants, enums, Status, TRANSITIONS, PERMISSIONS |
| `qms_auth.py` | ~150 | get_current_user, check_permission, verify_user_identity |
| `qms_paths.py` | ~100 | get_doc_path, get_archive_path, get_workspace_path, get_next_number |
| `qms_io.py` | ~150 | parse_frontmatter, serialize_frontmatter, read_document, write_document |
| `qms_templates.py` | ~300 | generate_review_task_content, load_template_for_type |
| `qms_commands.py` | ~1600 | All 21 cmd_* functions |
| `qms.py` | ~200 | Entry point: main(), argparse, command dispatch |

**Note:** These are target estimates. Actual line counts and module boundaries may shift during implementation as better interfaces emerge.

### 5.3 Flexibility Provisions

This CR explicitly allows for iterative refinement during execution:

1. **Module boundary adjustments** - Exact function placements may shift based on dependency analysis
2. **Function signature refinements** - Better interfaces may emerge during testing and extraction
3. **Incremental test coverage** - Tests added iteratively; 100% coverage not required
4. **Iterative pair-coding** - EI structure supports multiple iterations within each extraction phase

The executor may make reasonable adjustments to the implementation details as long as the end state satisfies the objectives: modular code structure and passing tests.

---

## 6. Justification

- **Maintainability:** A 2743-line file is difficult to navigate and understand
- **Testability:** Smaller modules with focused responsibilities are easier to test
- **Collaboration:** Multiple contributors can work on different modules without merge conflicts
- **Consistency:** Existing `qms_meta.py`, `qms_audit.py`, `qms_schema.py` demonstrate the pattern; `qms.py` should follow
- **Risk mitigation:** Unit tests provide safety net for this and future changes

---

## 7. Impact Assessment

### 7.1 Files Affected

| File | Change Type | Description |
|------|-------------|-------------|
| `qms-cli/qms.py` | Modify | Reduce to entry point with argparse and dispatch |
| `qms-cli/qms_config.py` | Create | Constants, enums, state machine definitions |
| `qms-cli/qms_auth.py` | Create | User authentication and permission functions |
| `qms-cli/qms_paths.py` | Create | Path resolution and document location functions |
| `qms-cli/qms_io.py` | Create | Document I/O and frontmatter parsing |
| `qms-cli/qms_templates.py` | Create | Template loading and content generation |
| `qms-cli/qms_commands.py` | Create | All command handler functions |
| `tests/test_qms_paths.py` | Create | Unit tests for path functions |
| `tests/test_qms_io.py` | Create | Unit tests for I/O functions |
| `tests/test_qms_auth.py` | Create | Unit tests for auth functions |

### 7.2 Documents Affected

| Document | Change Type | Description |
|----------|-------------|-------------|
| None | - | No QMS documents affected |

### 7.3 Other Impacts

None. Internal refactoring only; CLI interface and behavior remain unchanged.

---

## 8. Testing Summary

- **Unit tests run before refactoring:** Establish baseline on current monolith
- **Unit tests run after each module extraction:** Verify no regressions
- **Unit tests run after final cleanup:** Comprehensive verification
- **CLI smoke test:** Verify `python qms-cli/qms.py --help` and basic commands work

---

## 9. Implementation Plan

### 9.1 Phase 1: Test Infrastructure

1. Set up pytest and tests/ directory
2. Write unit tests for path functions (targeting current monolith)
3. Write unit tests for I/O functions (targeting current monolith)
4. Write unit tests for auth functions (targeting current monolith)
5. Verify all tests pass on current monolith (baseline)

### 9.2 Phase 2: Module Extraction

6. Extract config module; verify tests pass
7. Extract paths module; verify tests pass
8. Extract I/O module; verify tests pass
9. Extract auth module; verify tests pass
10. Extract templates module; verify tests pass
11. Extract commands module; verify tests pass

### 9.3 Phase 3: Cleanup

12. Final cleanup of qms.py; comprehensive test run

---

## 10. Execution

<!--
EXECUTION PHASE INSTRUCTIONS
============================
NOTE: Do NOT delete this comment block. It provides guidance for execution.

- Sections 1-9 are PRE-APPROVED content - do NOT modify during execution
- Only THIS TABLE and the comment sections below should be edited during execution phase

COLUMNS:
- EI: Execution item identifier
- Task Description: What to do (static, from Implementation Plan)
- Execution Summary: Narrative of what was done, evidence, observations (editable)
- Task Outcome: Pass or Fail (editable)
- Performed By - Date: Signature (editable)

TASK OUTCOME:
- Pass: Task completed as planned
- Fail: Task could not be completed as planned - attach VAR with explanation

VAR TYPES (see VAR-TEMPLATE):
- Type 1: Use when the failed task is critical to CR objectives
- Type 2: Use when impact is contained and CR can conceptually close

EXECUTION SUMMARY EXAMPLES:
- "Implemented per plan. Commit abc123."
- "Modified src/module.py:45-67. Unit tests passing."
- "Created SOP-007 (now EFFECTIVE)."
-->

| EI | Task Description | Execution Summary | Task Outcome | Performed By - Date |
|----|------------------|-------------------|--------------|---------------------|
| EI-1 | Set up test infrastructure (pytest, tests/ directory) | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-2 | Write unit tests for path functions | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-3 | Write unit tests for I/O functions | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-4 | Write unit tests for auth functions | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-5 | Verify all tests pass on current monolith (baseline) | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-6 | Extract config module; verify tests pass | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-7 | Extract paths module; verify tests pass | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-8 | Extract I/O module; verify tests pass | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-9 | Extract auth module; verify tests pass | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-10 | Extract templates module; verify tests pass | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-11 | Extract commands module; verify tests pass | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |
| EI-12 | Final cleanup of qms.py; comprehensive test run | [SUMMARY] | [Pass/Fail] | [PERFORMER] - [DATE] |

<!--
NOTE: Do NOT delete this comment. It provides guidance during document execution.

Add rows as needed. When adding rows, fill columns 3-5 during execution.
-->

---

### Execution Comments

| Comment | Performed By - Date |
|---------|---------------------|
| [COMMENT] | [PERFORMER] - [DATE] |

<!--
NOTE: Do NOT delete this comment. It provides guidance during document execution.

Record observations, decisions, or issues encountered during execution.
Add rows as needed.

This section is the appropriate place to attach VARs that do not apply
to any individual execution item, but apply to the CR as a whole.
-->

---

## 11. Execution Summary

<!--
NOTE: Do NOT delete this comment. It provides guidance during document execution.

Complete this section after all EIs are executed.
Summarize the overall outcome and any deviations from the plan.
-->

[EXECUTION_SUMMARY]

---

## 12. References

- **SOP-001:** Document Control
- **SOP-002:** Change Control

---

**END OF DOCUMENT**
