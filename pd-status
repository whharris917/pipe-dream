#!/bin/bash
# pd-status — Pipe Dream process overview utility
#
# Shows status of all Pipe Dream background services, containers, and
# flags stale PID files. Zero Python dependencies.
#
# Usage:
#   ./pd-status              # Show status overview
#   ./pd-status --stop-all   # Kill all services and remove containers
#
# Authorized by: CR-062

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# --- Colors ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# --- Service definitions ---
# Format: "label:port:pid_file:health_path"
SERVICES=(
    "QMS MCP:8000:.qms-mcp-server.pid:/mcp"
    "Git MCP:8001:.git-mcp-server.pid:/mcp"
    "Agent Hub:9000:.agent-hub.pid:/api/health"
)

# --- Container name patterns from launch.sh ---
# launch.sh names containers "agent-{name}", docker-compose uses "docker-claude-agent-1"
CONTAINER_FILTERS=("name=agent-")

# --- Helpers ---

# Check if a PID is alive. Uses tasklist.exe on Windows (Git Bash), kill -0 elsewhere.
pid_alive() {
    local pid="$1"
    if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "mingw"* || "$OSTYPE" == "cygwin" ]]; then
        tasklist.exe 2>/dev/null | grep -qE "^\S+\s+${pid}\s"
    else
        kill -0 "$pid" 2>/dev/null
    fi
}

# Probe a port via curl. Returns 0 if any HTTP response received.
port_alive() {
    local port="$1"
    local path="$2"
    local code
    code=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${port}${path}" 2>/dev/null || echo "000")
    [[ "$code" != "000" ]]
}

# Get the HTTP status code from a health endpoint.
health_code() {
    local port="$1"
    local path="$2"
    curl -s -o /dev/null -w "%{http_code}" "http://localhost:${port}${path}" 2>/dev/null || echo "000"
}

# --- Stop-all mode ---

stop_all() {
    echo -e "${BOLD}Pipe Dream — Stop All${NC}"
    echo -e "═══════════════════════════════════════════════"
    echo ""

    # Enumerate what will be stopped
    local has_work=false

    for svc in "${SERVICES[@]}"; do
        IFS=':' read -r label port pidfile healthpath <<< "$svc"
        local pidfile_path="${SCRIPT_DIR}/${pidfile}"
        if [ -f "$pidfile_path" ] || port_alive "$port" "$healthpath"; then
            has_work=true
            break
        fi
    done

    local containers
    containers=$(docker ps -a --filter "name=agent-" --format "{{.Names}}" 2>/dev/null || true)
    if [ -n "$containers" ]; then
        has_work=true
    fi

    if [ "$has_work" = false ]; then
        echo -e "  ${DIM}Nothing to stop — no services or containers found.${NC}"
        echo ""
        return 0
    fi

    # Show what will be stopped
    echo -e "  ${YELLOW}The following will be stopped:${NC}"
    echo ""

    for svc in "${SERVICES[@]}"; do
        IFS=':' read -r label port pidfile healthpath <<< "$svc"
        local pidfile_path="${SCRIPT_DIR}/${pidfile}"
        local pid=""
        [ -f "$pidfile_path" ] && pid=$(cat "$pidfile_path" 2>/dev/null || true)
        if [ -n "$pid" ] || port_alive "$port" "$healthpath"; then
            printf "    %-12s :%-5s" "$label" "$port"
            [ -n "$pid" ] && printf "  (PID %s)" "$pid"
            echo ""
        fi
    done

    if [ -n "$containers" ]; then
        echo ""
        echo "$containers" | while read -r name; do
            echo "    Container: $name"
        done
    fi

    echo ""
    read -r -p "  Proceed? [y/N] " confirm
    if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
        echo -e "  ${DIM}Cancelled.${NC}"
        return 0
    fi

    echo ""

    # Kill services
    for svc in "${SERVICES[@]}"; do
        IFS=':' read -r label port pidfile healthpath <<< "$svc"
        local pidfile_path="${SCRIPT_DIR}/${pidfile}"
        local pid=""
        [ -f "$pidfile_path" ] && pid=$(cat "$pidfile_path" 2>/dev/null || true)

        if [ -n "$pid" ] && pid_alive "$pid"; then
            if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "mingw"* || "$OSTYPE" == "cygwin" ]]; then
                taskkill.exe //PID "$pid" //F >/dev/null 2>&1 || true
            else
                kill "$pid" 2>/dev/null || true
            fi
            echo -e "  ${GREEN}✓${NC} Killed $label (PID $pid)"
        fi

        if [ -f "$pidfile_path" ]; then
            rm -f "$pidfile_path"
            echo -e "  ${GREEN}✓${NC} Removed $pidfile"
        fi
    done

    # Also remove legacy .mcp-server.pid if present
    local legacy_pid="${SCRIPT_DIR}/.mcp-server.pid"
    if [ -f "$legacy_pid" ]; then
        local lpid
        lpid=$(cat "$legacy_pid" 2>/dev/null || true)
        if [ -n "$lpid" ] && pid_alive "$lpid"; then
            if [[ "$OSTYPE" == "msys" || "$OSTYPE" == "mingw"* || "$OSTYPE" == "cygwin" ]]; then
                taskkill.exe //PID "$lpid" //F >/dev/null 2>&1 || true
            else
                kill "$lpid" 2>/dev/null || true
            fi
        fi
        rm -f "$legacy_pid"
        echo -e "  ${GREEN}✓${NC} Removed .mcp-server.pid (legacy)"
    fi

    # Stop containers
    if [ -n "$containers" ]; then
        echo "$containers" | while read -r name; do
            docker rm -f "$name" >/dev/null 2>&1 || true
            echo -e "  ${GREEN}✓${NC} Removed container $name"
        done
    fi

    echo ""
    echo -e "  ${GREEN}Done.${NC}"
    echo ""
}

# --- Status mode ---

show_status() {
    echo -e "${BOLD}Pipe Dream Status${NC}"
    echo -e "═══════════════════════════════════════════════"
    echo ""

    local warnings=()

    # --- Services ---
    echo -e "${CYAN}Services${NC}"

    for svc in "${SERVICES[@]}"; do
        IFS=':' read -r label port pidfile healthpath <<< "$svc"
        local pidfile_path="${SCRIPT_DIR}/${pidfile}"

        # Read PID file
        local file_pid=""
        local file_exists=false
        if [ -f "$pidfile_path" ]; then
            file_exists=true
            file_pid=$(cat "$pidfile_path" 2>/dev/null | tr -d '[:space:]')
        fi

        # Check PID alive
        local pid_is_alive=false
        if [ -n "$file_pid" ] && pid_alive "$file_pid"; then
            pid_is_alive=true
        fi

        # Probe port
        local port_is_alive=false
        if port_alive "$port" "$healthpath"; then
            port_is_alive=true
        fi

        # Determine status and build output line
        if [ "$port_is_alive" = true ]; then
            # Port is responding — service is running
            local status="${GREEN}RUNNING${NC}"
            local suffix=""

            if [ "$pid_is_alive" = true ]; then
                suffix="  ${DIM}(PID ${file_pid})${NC}"
            elif [ "$file_exists" = true ]; then
                suffix="  ${DIM}(port responding, PID file stale)${NC}"
                warnings+=("${pidfile} contains PID ${file_pid} which is not running, but port :${port} is active")
            fi

            # Special: Hub agent summary
            if [ "$label" = "Agent Hub" ]; then
                local hub_json
                hub_json=$(curl -s "http://localhost:${port}/api/status" 2>/dev/null || true)
                if [ -n "$hub_json" ]; then
                    local running stopped
                    running=$(echo "$hub_json" | { grep -o '"state":"running"' || true; } | wc -l)
                    stopped=$(echo "$hub_json" | { grep -o '"state":"stopped"' || true; } | wc -l)
                    if [ "$running" -gt 0 ] 2>/dev/null; then
                        suffix="${suffix}  ${DIM}(${running} agents running, ${stopped} stopped)${NC}"
                    fi
                fi
            fi

            printf "  %-12s :%-5s %b%b\n" "$label" "$port" "$status" "$suffix"

        elif [ "$pid_is_alive" = true ]; then
            # PID alive but port not responding — starting or broken
            printf "  %-12s :%-5s ${YELLOW}PID ALIVE${NC}  ${DIM}(PID ${file_pid}, port not responding)${NC}\n" "$label" "$port"
            warnings+=("${label}: PID ${file_pid} is running but port :${port} is not responding")

        else
            # Nothing running
            printf "  %-12s :%-5s ${RED}STOPPED${NC}\n" "$label" "$port"

            if [ "$file_exists" = true ]; then
                warnings+=("${pidfile} is stale (PID ${file_pid} not running)")
            fi
        fi
    done

    # Check for legacy .mcp-server.pid
    local legacy_pid="${SCRIPT_DIR}/.mcp-server.pid"
    if [ -f "$legacy_pid" ]; then
        local lpid
        lpid=$(cat "$legacy_pid" 2>/dev/null | tr -d '[:space:]')
        warnings+=(".mcp-server.pid exists (legacy, PID ${lpid}) — safe to remove")
    fi

    echo ""

    # --- Containers ---
    echo -e "${CYAN}Containers${NC}"

    local has_containers=false
    if command -v docker &>/dev/null; then
        local container_lines
        container_lines=$(docker ps -a --filter "name=agent-" --format "{{.Names}}\t{{.State}}\t{{.Status}}" 2>/dev/null || true)

        if [ -n "$container_lines" ]; then
            has_containers=true
            while IFS=$'\t' read -r name state status_str; do
                local state_color="$DIM"
                case "$state" in
                    running) state_color="$GREEN" ;;
                    exited)  state_color="$RED" ;;
                    *)       state_color="$YELLOW" ;;
                esac
                printf "  %-20s ${state_color}%-10s${NC} %s\n" "$name" "${state^^}" "$status_str"
            done <<< "$container_lines"
        fi
    fi

    if [ "$has_containers" = false ]; then
        echo -e "  ${DIM}No pipe-dream containers found.${NC}"
    fi

    echo ""

    # --- Warnings ---
    if [ ${#warnings[@]} -gt 0 ]; then
        echo -e "${YELLOW}Warnings${NC}"
        for w in "${warnings[@]}"; do
            echo -e "  ${YELLOW}!${NC} $w"
        done
        echo ""
    fi
}

# --- Main ---

case "${1:-}" in
    --stop-all)
        stop_all
        ;;
    --help|-h)
        echo "Usage: pd-status [--stop-all]"
        echo ""
        echo "Show status of Pipe Dream background services and containers."
        echo ""
        echo "Options:"
        echo "  --stop-all   Kill all services and remove containers"
        echo "  --help       Show this help"
        ;;
    "")
        show_status
        ;;
    *)
        echo "Unknown option: $1"
        echo "Usage: pd-status [--stop-all]"
        exit 1
        ;;
esac
